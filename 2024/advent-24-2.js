let input = `x00: 1
x01: 0
x02: 0
x03: 1
x04: 1
x05: 0
x06: 0
x07: 0
x08: 0
x09: 0
x10: 0
x11: 1
x12: 0
x13: 1
x14: 1
x15: 1
x16: 1
x17: 0
x18: 0
x19: 1
x20: 0
x21: 0
x22: 1
x23: 1
x24: 1
x25: 0
x26: 1
x27: 1
x28: 0
x29: 1
x30: 0
x31: 1
x32: 0
x33: 1
x34: 0
x35: 1
x36: 1
x37: 0
x38: 1
x39: 1
x40: 1
x41: 1
x42: 0
x43: 1
x44: 1
y00: 1
y01: 0
y02: 0
y03: 1
y04: 1
y05: 1
y06: 0
y07: 0
y08: 0
y09: 1
y10: 0
y11: 0
y12: 0
y13: 1
y14: 1
y15: 0
y16: 1
y17: 0
y18: 1
y19: 1
y20: 1
y21: 0
y22: 0
y23: 1
y24: 1
y25: 1
y26: 0
y27: 1
y28: 0
y29: 1
y30: 0
y31: 0
y32: 0
y33: 1
y34: 1
y35: 1
y36: 1
y37: 0
y38: 0
y39: 0
y40: 0
y41: 1
y42: 0
y43: 1
y44: 1

x36 AND y36 -> rpc
swn OR jrk -> kfm
x36 XOR y36 -> mvv
y28 XOR x28 -> rnh
bfp OR wqc -> rgb
tkc OR mfm -> brs
kmb XOR gfj -> z16
x25 AND y25 -> mdt
mpp AND hfd -> gjp
dhd AND mvb -> vrf
y14 XOR x14 -> qvt
shc OR bkk -> wvr
x29 AND y29 -> gdn
x11 XOR y11 -> jpp
rws OR fts -> mpp
wmq OR ngr -> knj
x24 XOR y24 -> gfg
tpf AND mgq -> tkc
wvr XOR jgw -> fkp
brs AND nmr -> qpb
x18 AND y18 -> qsw
pnb OR vjh -> sfh
x44 XOR y44 -> gcd
x22 AND y22 -> mhd
x37 XOR y37 -> dgg
vfj XOR dmh -> z15
x30 XOR y30 -> qgd
rpw OR gdn -> wrv
ptj OR vqm -> vjn
gfg AND pqf -> pnb
x17 XOR y17 -> rtv
y19 AND x19 -> wpt
sfp AND sbq -> tcv
hvv OR vmr -> kpq
pgc XOR fvj -> z02
knj AND ctw -> vqm
y42 XOR x42 -> vfb
y13 XOR x13 -> vdk
x43 AND y43 -> nhd
krg XOR dkw -> z43
y32 AND x32 -> vdm
hfd XOR mpp -> z08
nfq OR qgm -> cqq
x02 AND y02 -> nss
rvw XOR dtb -> z10
qvt AND qqv -> rgj
mvv XOR sgr -> z36
y11 AND x11 -> wmq
cnd XOR jqv -> z29
vdk XOR vjn -> z13
x34 AND y34 -> kjj
qvt XOR qqv -> z14
y18 XOR x18 -> mkt
bwk OR krn -> pqf
nhs XOR cqq -> z41
y31 AND x31 -> z31
y23 AND x23 -> bwk
sfh AND pmf -> ctp
rvw AND dtb -> sgv
tns AND chq -> dwv
rqt XOR snv -> z22
jqv AND cnd -> rpw
x33 AND y33 -> vtd
ctw XOR knj -> z12
bpp OR ghf -> z06
ffn AND rdj -> shc
cfw OR tnc -> sgr
wdm AND psv -> fwc
vwn OR wpt -> bvc
jkn OR gvk -> z45
x00 XOR y00 -> z00
qpf XOR mkt -> z18
y12 AND x12 -> ptj
dvq XOR rkm -> z04
x15 XOR y15 -> dmh
qrm OR nss -> wdm
mhv OR mnv -> rcs
qtq OR cqn -> nwk
x20 XOR y20 -> tpw
x04 AND y04 -> ptd
nhd OR pnk -> mdn
hjc OR hth -> pgc
x20 AND y20 -> qtq
gcd XOR mdn -> z44
mgq XOR tpf -> mfm
x30 AND y30 -> bbk
dmh AND vfj -> cpc
x44 AND y44 -> gvk
dwv OR jvf -> jjj
pkh AND fkp -> rws
x39 AND y39 -> wqc
fwc OR nbc -> rkm
bdc AND bbd -> dnc
x26 XOR y26 -> tns
csh AND mst -> vwn
x43 XOR y43 -> dkw
bvc XOR tpw -> z20
nwk XOR ngm -> z21
rtv XOR kfm -> z17
x06 AND y06 -> bpp
x10 XOR y10 -> dtb
y29 XOR x29 -> cnd
y08 XOR x08 -> hfd
y03 XOR x03 -> psv
rgj OR bph -> vfj
psv XOR wdm -> z03
dnc OR vtd -> mvb
gcn AND tqf -> krn
y38 XOR x38 -> krj
x24 AND y24 -> vjh
y41 AND x41 -> vmr
jgw AND wvr -> ghf
x09 XOR y09 -> sfp
y28 AND x28 -> wpw
x40 XOR y40 -> mkc
hsn AND dgg -> snc
jpp XOR stv -> ngr
mjb OR cpc -> gfj
rcs XOR rnh -> z28
sfp XOR sbq -> z09
rtv AND kfm -> jfr
tjh OR wpw -> jqv
x16 XOR y16 -> kmb
bgn OR wnm -> snv
nmr XOR brs -> z32
rpc OR dvm -> hsn
gfg XOR pqf -> z24
dkw AND krg -> pnk
kmb AND gfj -> jrk
skt XOR kjn -> z01
gcn XOR tqf -> z23
jjj XOR rhc -> z27
y07 AND x07 -> fts
y21 AND x21 -> wnm
kvd OR snc -> ntr
nht XOR hsp -> z39
wrv XOR qgd -> z30
y07 XOR x07 -> pkh
tdv OR krj -> hsp
stv AND jpp -> z11
x27 AND y27 -> mhv
bdc XOR bbd -> z33
x12 XOR y12 -> ctw
mvv AND sgr -> dvm
x27 XOR y27 -> rhc
x21 XOR y21 -> ngm
mhn XOR mdg -> z35
x19 XOR y19 -> csh
y35 XOR x35 -> mhn
snv AND rqt -> tfs
rkm AND dvq -> cjp
pgc AND fvj -> qrm
kpq XOR vfb -> z42
qgd AND wrv -> gqt
y26 AND x26 -> jvf
x39 XOR y39 -> nht
vdk AND vjn -> jqm
bvc AND tpw -> cqn
y32 XOR x32 -> nmr
x25 XOR y25 -> pmf
y09 AND x09 -> prs
y14 AND x14 -> bph
qpb OR vdm -> bdc
gqt OR bbk -> tpf
x40 AND y40 -> qgm
sfh XOR pmf -> z25
x22 XOR y22 -> rqt
rhc AND jjj -> mnv
csh XOR mst -> z19
x42 AND y42 -> krw
x34 XOR y34 -> dhd
x35 AND y35 -> tnc
ngm AND nwk -> bgn
tdh OR jqm -> qqv
y00 AND x00 -> skt
y41 XOR x41 -> nhs
ntr XOR bpt -> z38
vrf OR kjj -> mdg
kvf OR krw -> krg
x03 AND y03 -> nbc
dhd XOR mvb -> z34
qpf AND mkt -> rsd
y01 XOR x01 -> kjn
x17 AND y17 -> bvg
jfr OR bvg -> qpf
y13 AND x13 -> tdh
bpb OR gjp -> sbq
x16 AND y16 -> swn
x02 XOR y02 -> fvj
y15 AND x15 -> mjb
x23 XOR y23 -> tqf
rnh AND rcs -> tjh
x05 AND y05 -> bkk
hsn XOR dgg -> z37
qsw OR rsd -> mst
sgv OR qnf -> stv
y01 AND x01 -> hth
y38 AND x38 -> bpt
rgb AND mkc -> nfq
y33 XOR x33 -> bbd
tns XOR chq -> z26
ctp OR mdt -> chq
nhs AND cqq -> hvv
pkh XOR fkp -> z07
rdj XOR ffn -> z05
mhd OR tfs -> gcn
y10 AND x10 -> qnf
hsp AND nht -> bfp
gcd AND mdn -> jkn
ntr AND bpt -> tdv
prs OR tcv -> rvw
x05 XOR y05 -> ffn
y04 XOR x04 -> dvq
x31 XOR y31 -> mgq
y08 AND x08 -> bpb
mhn AND mdg -> cfw
y37 AND x37 -> kvd
rgb XOR mkc -> z40
cjp OR ptd -> rdj
x06 XOR y06 -> jgw
skt AND kjn -> hjc
vfb AND kpq -> kvf`;

input = input.split("\n\n").map((str) => str.split("\n"));

const wires = input[0]
  .map((str) => str.split(": "))
  .map(([wire, value]) => [wire, +value]);

const gates = (input[1] = input[1].map((str) => str.split(" ")));
gates.forEach((arr) => arr.splice(3, 1));

function getZAfterSwap(swaps, modifiedWires = wires) {
  const dict = {};
  for (const [wire, value] of modifiedWires) dict[wire] = value;

  let gatesAfterSwap = [...gates];
  for (const [swapIndex1, swapIndex2] of swaps) {
    gatesAfterSwap[swapIndex1] = [...gatesAfterSwap[swapIndex1]];
    gatesAfterSwap[swapIndex2] = [...gatesAfterSwap[swapIndex2]];
    [gatesAfterSwap[swapIndex1][3], gatesAfterSwap[swapIndex2][3]] = [
      gatesAfterSwap[swapIndex2][3],
      gatesAfterSwap[swapIndex1][3],
    ];
  }

  function updateDict() {
    let numUpdates = 0;
    for (const [wire1, gate, wire2, resultWire] of gatesAfterSwap) {
      const value1 = dict[wire1];
      const value2 = dict[wire2];
      if (
        value1 === undefined ||
        value2 === undefined ||
        dict[resultWire] !== undefined
      )
        continue;

      switch (gate) {
        case "AND":
          dict[resultWire] = value1 && value2;
          break;
        case "OR":
          dict[resultWire] = value1 || value2;
          break;
        case "XOR":
          dict[resultWire] = +(value1 !== value2);
          break;
      }
      numUpdates++;
    }

    return numUpdates;
  }

  while (updateDict());

  function getBinary(wireLetter) {
    let str = Object.entries(dict)
      .filter(([wire]) => wire[0].startsWith(wireLetter))
      .sort(([a], [b]) => (a > b ? -1 : 1))
      .map(([, value]) => value)
      .join("");
    str = "0".repeat(46 - str.length) + str;
    return str;
  }

  function getBase10(wireLetter) {
    return parseInt(getBinary(wireLetter), 2);
  }

  return getBinary("z");
}

const zNoSwap = getZAfterSwap([]);

const goalZ = "1101011111100011011001011001110100101001010010";

const group1 = [4, 8];
const group2 = [13, 15];
const group3 = [33, 35];
const group4 = [38, 40];

function getPossibleSwapIndices(group) {
  const swapIndices = [];
  for (let swapIndex1 = 0; swapIndex1 < gates.length; swapIndex1++)
    for (
      let swapIndex2 = swapIndex1 + 1;
      swapIndex2 < gates.length;
      swapIndex2++
    ) {
      let zAfterSwap = getZAfterSwap([[swapIndex1, swapIndex2]]);
      zAfterSwap = "0".repeat(zNoSwap.length - zAfterSwap.length) + zAfterSwap;
      if (
        zAfterSwap.slice(0, group[0]) === zNoSwap.slice(0, group[0]) &&
        zAfterSwap.slice(group[0], group[1]) ===
          goalZ.slice(group[0], group[1]) &&
        zAfterSwap.slice(group[1]) === zNoSwap.slice(group[1])
      ) {
        swapIndices.push([swapIndex1, swapIndex2]);
      }
    }
  return swapIndices;
}

const swapIndices1 = getPossibleSwapIndices(group1);
const swapIndices2 = getPossibleSwapIndices(group2);
const swapIndices3 = getPossibleSwapIndices(group3);
const swapIndices4 = getPossibleSwapIndices(group4);

const validSwapsForInput = [];

for (const swap1 of swapIndices1)
  for (const swap2 of swapIndices2)
    for (const swap3 of swapIndices3)
      for (const swap4 of swapIndices4) {
        if (getZAfterSwap([swap1, swap2, swap3, swap4]) === goalZ) {
          validSwapsForInput.push([swap1, swap2, swap3, swap4]);
        }
      }

console.log(validSwapsForInput.length, "swaps valid for input");

function getNumCorrect(swaps) {
  let correct = 0;
  for (let i = 0; i < 100; i++) {
    let x = Math.floor(Math.random() * 2 ** 44);
    let y = Math.floor(Math.random() * 2 ** 44);
    let sum = x + y;

    let xBinary = x.toString(2);
    xBinary = "0".repeat(46 - xBinary.length) + xBinary;
    let yBinary = y.toString(2);
    yBinary = "0".repeat(46 - yBinary.length) + yBinary;
    let sumBinary = sum.toString(2);
    sumBinary = "0".repeat(46 - sumBinary.length) + sumBinary;

    const wires = [];
    for (let i = 0; i <= 44; i++) {
      let str = i.toString();
      if (str.length === 1) str = "0" + str;

      wires.push([`x${str}`, +xBinary[46 - 1 - i]]);
      wires.push([`y${str}`, +yBinary[46 - 1 - i]]);
    }

    if (getZAfterSwap(swaps, wires) === sumBinary) correct++;
  }
  return correct;
}

for (const swaps of validSwapsForInput) {
  if (getNumCorrect(swaps) === 100) {
    const [[a, b], [c, d], [e, f], [g, h]] = swaps;
    let result = [
      gates[a][3],
      gates[b][3],
      gates[c][3],
      gates[d][3],
      gates[e][3],
      gates[f][3],
      gates[g][3],
      gates[h][3],
    ];
    result = result.sort().join(",");
    console.log(result);
    return;
  }
}

// console.log(getNumCorrect([]));

// diff in binary
// 100000010000000000000000000100001000000

// z no swap == 1101100011100101011001011001110101001010010010 == 59619940979346

// => we must flip the digits at 6, 11, 31, 38
// => each 0 to 1
// => must flip z06, z11, z31, z38 without affecting others?

// 220 gates
// 220*219/2 == 24,090 possible pairs to consider
// we need to choose 4 pairs

// 100

// example
// x == 101010 == 42
// y == 101100 == 44
// z == 001001 == 9

// swap z05 amd z00
// z == 101000 == 40

// swap z02 and z01
//

// x     == 30626032511001 ==  0110111101101010101101110010011110100000011001
// y     == 28716883075641 ==  0110100001111000101011100111010110001000111001
// x + y == 59342915586642 ==  1101011111100011011001011001110100101001010010
// z     == 59619940979346 ==  1101100011100101011001011001110101001010010010
//                             0000000100000010000000000000000000100001000000

//               xxxx       xx                    xx     xx
// x + y == 1101 0111 11100 01 101100101100111010 01 010 01 010010
// z     == 1101 1000 11100 10 101100101100111010 10 010 10 010010

// z too large by 277025392704 or:
// 0000000100000010000000000000000000100001000000

// swaps for first group
// 108 115
// 108 134
// 108 176
// 108 197
// 108 216
// 115 155
// 134 155
// 138 176
// 155 176
// 155 197
// 155 216

// swaps for second group
// 5 55
// 55 84
// 55 124
// 55 213

// swaps for third group
// 15 139
// 63 139
// 116 139

// swaps for fourth group
// 11 99
// 18 64
// 18 99
// 18 111
// 64 203
// 65 99
// 99 203
// 111 203
